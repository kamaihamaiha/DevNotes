### 崩溃优化

- 崩溃现场
- 崩溃分析

#### 崩溃现场

应该采集的信息：
- 崩溃信息
    - 进程名、线程名
    - 崩溃堆栈和类型
        - Java 崩溃、Native 崩溃还是 ANR
- 系统信息
    - Logcat
    - 机型、系统、厂商、CPU、ABI、Linux 版本
    - 设备状态  
        - 是否 Root，是否模拟器
- 内存信息
    - 系统剩余内存
      ```text
       系统内存状态：可直接读取文件 /proc/meminfo
       当系统可用内存很小（低于 MemTotal 的  10%）时，OOM、大量 GC、系统频繁自杀拉起等问题非常容易出现。
      ```
    - 应用使用内存
      ```text
       包括 Java 内存、RSS（Resident Set Size）、PSS（Proportion Set Size），可以得出应用本身内存的占用大小和分布。
       PSS 和 RSS 通过 /proc/self/smap 计算，可进一步得到例如：apk、dex、so 等更加详细的分类统计
      ```
    - 虚拟内存
        - 虚拟内存可以通过 /proc/self/status 得到，通过 /proc/self/maps 文件可以得到具体的分布情况。
        - 有时候我们一般不太重视虚拟内存，但很多类似 OOM、tgkill 等问题都是虚拟内存不足导致的。
        - 一般来说，32 位进程，如果是 32 位 CPU，虚拟内存达到 3GB 就会引起内存申请失败。如果是 64 位 CPU，虚拟内存一般在 3~4GB。如果支持 64位 进程，虚拟内存就不会成问题。
        - GooglePlay 要求 2019年 8 月一定要支持 64 位，但国内商店是不支持区分 CPU 架构类型发布的。
    - 资源信息
        - 有时候堆内存和设备内存都非常充足，还是出现 内存分配失败，这可能根资源泄漏有关。
        - 文件句柄 fd。文件句柄限制通过 /proc/self/limits 获得，一般单个进程允许打开都最大文件句柄个数位 1024，但是如果超过 800 个就比较危险
        - 线程数。当前线程数大小可以通过 /proc/self/status 得到。
          一个线程可能占 2MB 的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据经验，如果线程数 >400 就比较危险
    - 应用信息

#### 崩溃分析

- 第一步 确定重点
- 第二步 查找共性
- 第三步 尝试复现